<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s">
     <link rel="shortcut icon" href="/img/favicon.ico">
    <title>
        Polin &amp; Rophen&#39;s Corner
    </title>
    <meta name="description" content="This" is our website! welcome!>
    <meta name="keywords" content="Blog,Hexo,Theme">
    <link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">
    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/style.css">
</head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            数据结构-4-4-树和森林
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="44-树-森林"><a class="markdownIt-Anchor" href="#44-树-森林"></a> 4.4 树、森林</h1>
<a id="more"></a>
<h2 id="441-树的存储结构"><a class="markdownIt-Anchor" href="#441-树的存储结构"></a> 4.4.1 树的存储结构</h2>
<ol>
<li>双亲表示法<br>
利用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。根结点下标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，其伪指针域为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</li>
</ol>
<img src="/2020/01/19/考研2020/408/数据结构-4-4-树和森林/图4-9-树的双亲表示法.jpg" title="图4-9-树的双亲表示法">
<p>双亲结点的存储结构描述如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100   <span class="comment">// 树中最多结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>             <span class="comment">// 树的结点定义</span></span><br><span class="line">    ElemType data;          <span class="comment">// 数据元素</span></span><br><span class="line">    <span class="keyword">int</span> parent;             <span class="comment">// 双亲位置域</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>             <span class="comment">// 树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];    <span class="comment">// 双亲表示</span></span><br><span class="line">    <span class="keyword">int</span> n;                  <span class="comment">// 结点数</span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure>
<p>该存储结构利用了每个结点（除根结点之外）只有唯一一个双亲的性质，可以很快得到每个结点的双亲结点。但是求结点的孩子结点时却要遍历整个结构。</p>
<ol start="2">
<li>孩子表示法<br>
将每个结点的孩子结点都用单链表链接起来形成一个线性结构，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个结点就有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个孩子链表（叶子结点的孩子链表为空），如图4-10。<br>
对于这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个结点中孩子链表指针域所指向的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个孩子链表。</li>
</ol>
<img src="/2020/01/19/考研2020/408/数据结构-4-4-树和森林/图4-10-树的孩子表示法和孩子兄弟表示法.jpg" title="图4-10-树的孩子表示法和孩子兄弟表示法">
<ol start="3">
<li>孩子兄弟表示法<br>
又称二叉树表示法，即以二叉链表作为树的存储结构，孩子兄弟表示法是使每个结点包括三部分内容，结点值、指向结点第一个孩子结点的指针和指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点），如图4-10。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;      <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstChild</span>, * <span class="title">nextSibling</span>;</span>   <span class="comment">// 第一个孩子和右兄弟指针</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure>
<p>这种存储表示法比较灵活。其最大的优点就是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。如果为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便。</p>
<h2 id="442-树-森林与二叉树的转换"><a class="markdownIt-Anchor" href="#442-树-森林与二叉树的转换"></a> 4.4.2 树、森林与二叉树的转换</h2>
<h3 id="1-树转换为二叉树的规则"><a class="markdownIt-Anchor" href="#1-树转换为二叉树的规则"></a> 1. 树转换为二叉树的规则：</h3>
<p>每个结点左指针指向它的第一个孩子结点，右指针指向它在树中的相邻兄弟结点，可表示为“左孩子右兄弟”。由于根结点没有兄弟，所以，由树转换而得的二叉树没有右子树，如图4-11。</p>
<img src="/2020/01/19/考研2020/408/数据结构-4-4-树和森林/图4-11-树转换为二叉树.jpg" title="图4-11-树转换为二叉树">
<h3 id="2-二叉树转换为树的规则"><a class="markdownIt-Anchor" href="#2-二叉树转换为树的规则"></a> 2. 二叉树转换为树的规则：</h3>
<p>若二叉树非空，则二叉树根及其左子树为第一棵树的二叉树形式。二叉树根的右子树又可以看作是一个由除了第一棵树以外的森林转换后的二叉树，应用同样的方法，直到最后产生一棵没有右子树的二叉树为止，这样就得到的原森林，如图4-12.</p>
<img src="/2020/01/19/考研2020/408/数据结构-4-4-树和森林/图4-12-二叉树转换为树.jpg" title="图4-12-二叉树转换为树">
<ul>
<li>树转换为二叉树的画法：
<ol>
<li>在兄弟结点之间加一连线；</li>
<li>对每一个结点，只保留它与第一个子结点的连线，与其他子结点的连线全部抹掉；</li>
<li>以树根为轴心，顺时针旋转<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>45</mn><mi mathvariant="normal">°</mi></mrow><annotation encoding="application/x-tex">45°</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">5</span><span class="mord">°</span></span></span></span>。</li>
</ol>
</li>
<li>森林转换为二叉树的画法：
<ol>
<li>将每棵树的根相连；</li>
<li>将森林中的每棵树转换成相应的二叉树；</li>
<li>以第一棵树的根为轴心顺时针旋转<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>45</mn><mi mathvariant="normal">°</mi></mrow><annotation encoding="application/x-tex">45°</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">5</span><span class="mord">°</span></span></span></span>。</li>
</ol>
</li>
</ul>
<h2 id="443-树和森林的遍历"><a class="markdownIt-Anchor" href="#443-树和森林的遍历"></a> 4.4.3 树和森林的遍历</h2>
<h3 id="树的遍历方法"><a class="markdownIt-Anchor" href="#树的遍历方法"></a> 树的遍历方法</h3>
<p>树的遍历操作是以某种方式访问树中的每一个结点，且仅访问一次。树的遍历操作主要有先根遍历和后根遍历。<br>
1. 先根遍历：若树非空，则先访问根结点，再从左到右地遍历根结点的每一棵子树。其访问顺序与这棵树相应的先序遍历顺序相同。<br>
2. 后根遍历：若树非空，则从左到右地遍历根结点的每一棵子树，之后再访问根结点。其访问顺序与这棵树相应的中序遍历顺序相同。<br>
3. 另外，树也有层次遍历，与二叉树的层次遍历思想基本相同，即按次序依次访问各结点，</p>
<h3 id="森林的遍历方法"><a class="markdownIt-Anchor" href="#森林的遍历方法"></a> 森林的遍历方法</h3>
<p>按照森林和树相互递归的定义，可得到森林的两种遍历方法：<br>
1. 先序遍历。若森林非空，则按如下规则遍历：<br>
- 访问森林中第一棵树的根结点；<br>
- 先序遍历第一棵树中根结点的子树森林；<br>
- 先序遍历除去第一棵树之后剩余的树构成的森林。<br>
2. 中序遍历森林。若森林非空，则按如下规则遍历：<br>
- 中序遍历森林中第一棵树的根结点的子树森林；<br>
- 访问第一棵树的根结点；<br>
- 中序遍历除去第一棵树之后剩余的树构成的森林。</p>
<h2 id="444-树的应用并查集"><a class="markdownIt-Anchor" href="#444-树的应用并查集"></a> 4.4.4 树的应用——并查集</h2>
<p>并查集是一种简单的集合表示，它支持以下3种操作：</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>n</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi>R</mi><mi>o</mi><mi>o</mi><mi>t</mi><mn>1</mn><mo separator="true">,</mo><mi>R</mi><mi>o</mi><mi>o</mi><mi>t</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Union(S, Root1, Root2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>：把集合S中的子集合Root2并入子集合Root1中。要求Root1和Root2互不相交，否则不执行合并。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Find(S, x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>：查找集合S中氮元素x所在的子集合，并返回该子集合的名字。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Initial(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>：将集合S中每一个元素都初始化为只有一个单元素的子集合。<br>
通常用树（森林）的双亲表示作为并查集的存储结构，每个子集合以一棵树标书。所有表示子集合的树，构成标书全集合的森林，存放在双亲表示的数组内。通常用数组元素的下标代表元素名，根结点下标代表子集合名，根结点的双亲结点为负数。</li>
</ol>
<h3 id="结构定义"><a class="markdownIt-Anchor" href="#结构定义"></a> 结构定义</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="keyword">int</span> UFSets[SIZE];   <span class="comment">// 集合元素数组（双亲指针数组）</span></span><br></pre></td></tr></table></figure>
<h3 id="初始化操作"><a class="markdownIt-Anchor" href="#初始化操作"></a> 初始化操作</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">(<span class="keyword">int</span> S[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)   <span class="comment">// 每个自成单元素集合</span></span><br><span class="line">        s[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="find操作函数在并查集s中查找并返回包含元素x的树的根"><a class="markdownIt-Anchor" href="#find操作函数在并查集s中查找并返回包含元素x的树的根"></a> Find操作（函数在并查集S中查找并返回包含元素x的树的根）</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> x)</span></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(S[x] &gt;= <span class="number">0</span>)        <span class="comment">// 循环查找x的根</span></span><br><span class="line">        x = S[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="union操作函数求两个不相交子集合的并集"><a class="markdownIt-Anchor" href="#union操作函数求两个不相交子集合的并集"></a> Union操作（函数求两个不相交子集合的并集）</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> Root1, <span class="keyword">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 要去Root1与Root2是不同的，且表示子集合的名字</span></span><br><span class="line">    S[Root2] = Root1;       <span class="comment">// 将根Root2连接到另一根Root1下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错题"><a class="markdownIt-Anchor" href="#错题"></a> 错题</h2>
<h3 id="一-单选"><a class="markdownIt-Anchor" href="#一-单选"></a> 一、 单选</h3>
<h4 id="32009-将森林转换为对应的二叉树若在二叉树中阶段u是结点v的父结点的父结点则在原来的森林中u和v可能具有的关系是"><a class="markdownIt-Anchor" href="#32009-将森林转换为对应的二叉树若在二叉树中阶段u是结点v的父结点的父结点则在原来的森林中u和v可能具有的关系是"></a> 3.[2009] 将森林转换为对应的二叉树，若在二叉树中，阶段u是结点v的父结点的父结点，则在原来的森林中，u和v可能具有的关系是（ ）。</h4>
<p>I.  父子关系<br>
II. 兄弟关系<br>
III.u的父结点与v的父结点是兄弟关系<br>
A. 只有I<br>
B. I和II<br>
C. I和III<br>
D. I、II和III<br>
[Analysis]<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\therefore B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>✔️</p>
<h4 id="5-设森林f对应的二叉树为b它有m个结点b的根为p-p的右子树结点个数为n-森林f中第一棵树的结点个数为"><a class="markdownIt-Anchor" href="#5-设森林f对应的二叉树为b它有m个结点b的根为p-p的右子树结点个数为n-森林f中第一棵树的结点个数为"></a> 5. 设森林F对应的二叉树为B，它有m个结点，B的根为p。p的右子树结点个数为n。森林F中第一棵树的结点个数为（ ）。</h4>
<p>A. m-n<br>
B. m-n-1<br>
C. n+1<br>
D. 条件不足，无法判断<br>
[Analysis]<br>
森林转换成二叉树时采用孩子兄弟表示法。根结点及其左子树为森林中的第一棵树。右子树为其他剩余的树。所以，第一个数的结点个数为m-n。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\therefore A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>✔️</p>
<h4 id="82011-已知一棵有2011个结点的树其叶结点个数为116该树对应的二叉树中无右孩子的结点个数为"><a class="markdownIt-Anchor" href="#82011-已知一棵有2011个结点的树其叶结点个数为116该树对应的二叉树中无右孩子的结点个数为"></a> 8.[2011] 已知一棵有2011个结点的树，其叶结点个数为116，该树对应的二叉树中无右孩子的结点个数为（ ）。</h4>
<p>A. 115<br>
B. 116<br>
C. 1895<br>
D. 1896<br>
[Analysis]<br>
转换为二叉树时，树中每一个分支结点的所有子结点中的最右子结点无右孩子，根结点转换后也没有右孩子。因此，对应的二叉树中无右孩子的结点个数=分支结点数+1=2011-116+1=1896。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">\therefore D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span>✔️</p>
<h4 id="92014-将森林f转换为对应的二叉树tf中叶结点的个数等于"><a class="markdownIt-Anchor" href="#92014-将森林f转换为对应的二叉树tf中叶结点的个数等于"></a> 9.[2014] 将森林F转换为对应的二叉树T，F中叶结点的个数等于（ ）。</h4>
<p>A. T中叶结点的个数<br>
B. T中度为1的结点个数<br>
C. T中左孩子指针为空的结点个数<br>
D. T中右孩子指针为空的结点个数<br>
[Analysis]<br>
在变化过程中，原森林某结点的第一个孩子结点作为它的左子树，它的右兄弟作为它的右子树。那么森林中的叶结点由于没有孩子结点，转化为二叉树时。该结点就没有左结点，所以F中叶结点的个数就等于T中左孩子指针为空的结点的个数。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\therefore C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>✔️</p>
<h4 id="11-某二叉树结点的中序序列为bdaecf后序序列为dbefca则该二叉树对应的森林包括-棵树"><a class="markdownIt-Anchor" href="#11-某二叉树结点的中序序列为bdaecf后序序列为dbefca则该二叉树对应的森林包括-棵树"></a> 11. 某二叉树结点的中序序列为BDAECF，后序序列为DBEFCA，则该二叉树对应的森林包括（ ）棵树。</h4>
<p>A. 1<br>
B. 2<br>
C. 3<br>
D. 4<br>
[Analysis]</p>
<img src="/2020/01/19/考研2020/408/数据结构-4-4-树和森林/11.jpg" title="No.11">
<p>森林中树的棵树记为与其对应的二叉树中根结点A的兄弟数。可知此森林共三棵树，根结点分别为A，C，D。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\therefore B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>✔️</p>
<h4 id="122014-若森林f有15条边25个结点则f包含树的个数是"><a class="markdownIt-Anchor" href="#122014-若森林f有15条边25个结点则f包含树的个数是"></a> 12.[2014] 若森林F有15条边，25个结点，则F包含树的个数是（ ）。</h4>
<p>A. 8<br>
B. 9<br>
C. 10<br>
D. 11<br>
[Analysis]<br>
树有一个很重要的性质：在n个结点的树中有n-1条边。那么对于每棵树，其结点数比边数多1。题中的森林中结点数比边数多10（25-15=10），显然共有10棵树。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∴</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\therefore C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69224em;vertical-align:0em;"></span><span class="mrel amsrm">∴</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>✔️</p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>版权所有 © 2020 | 作者: Polin | 主题 By <a class="theme-author" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站浏览总访问量: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">本站访问人数: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="ctBCYK2W3TF5eRPTjp2muadC-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FiU9IopoRfSRQSW0i1PlePP3">
<script src="/libs/jquery.min.js"></script>
<script src="/libs/highlight/highlight.pack.js"></script>
<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script src="/js/js.js"></script>
<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
